<!DOCTYPE html>
<meta charset="utf-8">
<style>

svg {
  font: 10px sans-serif;
  padding: 10px;
}
.axis,
.frame {
  shape-rendering: crispEdges;
}
.axis line {
  stroke: #ddd;
}

.axis path {
  display: none;
}

text {
  font-weight: bold;
  font-size: 14px;
  text-transform: capitalize;
}

.cell text {
  font-weight: bold;
  font-size: 14px;
  text-transform: capitalize;
}

.frame {
  stroke: #444;
  stroke-width: ;
}
circle {
  fill-opacity: .8;
}
circle.hidden {
  fill: #ccc !important;
}
.extent {
  fill: #000;
  fill-opacity: .125;
  stroke: #fff;
}

</style>
<body>
<script src="//d3js.org/d3.v3.min.js"></script>
<script>
var width = 1200,
    size = 80,
    padding = size/20;

var x = d3.scale.linear()
    .range([padding , size - padding]);

var y = d3.scale.linear()
    .range([size - padding , padding ]);

var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom")
    .ticks(3);

var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left")
    .ticks(3);

var color = d3.scale.category10();

//******************************
var domainByTrait= ["0.0", "1.0"];

    

//d3.tsv("data/SonarStandardized.csv", function(error, data) {
d3.tsv("data/BreastStandardized.csv", function(error, data) {
  if (error) throw error;

  var traits = d3.keys(data[0]).filter(function(d) { return d !== ""; }),
      n = traits.length;

  var brush = d3.svg.brush()
      .x(x)
      .y(y)
      .on("brushstart", brushstart)
      .on("brush", brushmove)
      .on("brushend", brushend);

  var svg = d3.select("body").append("svg")
      .attr("width", size * n + padding)
      .attr("height", size * n + padding)
      .append("g")
        .attr("transform", "translate(" + padding + "," + padding / 2 + ")");

  var colorRedBlue = d3.scale.linear()
    .domain([0, 0.4, 1])
    .range(["#55f", "white", "red"]);


   svg.append("text")
      .attr("class", "textNotification")
      .attr("x", padding)
      .attr("y", padding)
      .text("Finished reading data points");
          

  // Reading Scagnostics data ***********************************************************
  // ********************************************************************************  
  d3.tsv("data/BreastOutput2.csv", function(error, data2) {
    svg.append("text")
      .attr("class", "textNotification")
      .attr("x", padding)
      .attr("y", padding+14)
      .text("Finished reading Scagnostics");


   var leaderList = leaderAlgorithm(traits, disSim);
   var varList = cross(traits);
   splom(svg, varList);

    // splom function ****************************
    function splom(svg_, varList) {
      var cell = svg_.selectAll(".cell")
        .data(varList)
        .enter().append("g")
        .attr("class", "cell")
        .attr("transform", function(d) { return "translate(" + (d.i) * size + "," + d.j * size + ")"; })
        .each(plot);

      // Titles for the diagonal.
      cell.filter(function(d) { return d.i === d.j; }).append("text")
          .attr("class", "varText")
          .attr("x", padding)
          .attr("y", size*0.8)
          .text(function(d,i) { return d.x; });
      cell.call(brush);   

      
    }  

    // Plot function *******************************
    function plot(p) {
      if ((p.i>32 || p.j>32 || p.i==p.j))
        return;
      var cell = d3.select(this);

      x.domain(domainByTrait);
      y.domain(domainByTrait);

      cell.append("rect")
          .attr("class", "frame")
          .attr("x", padding / 2)
          .attr("y", padding / 2)
          .attr("width", size - padding)
          .attr("height", size - padding)
          .style("fill", function(d) { 
              if (p.i<p.j){
                 var k = p.mj*(p.mj-1)/2+p.mi; 
                 return colorRedBlue(data2[k]["Monotonic"]);
              }
              else if (p.i>p.j){
                var k = p.mi*(p.mi-1)/2+p.mj; 
                return colorRedBlue(data2[k]["Monotonic"]);
              }
              else{
                return "#fff";
              }
          });
      cell.selectAll("circle")
          .data(data)
        .enter().append("circle")
          .attr("cx", function(d) { return x(d[p.x]); })
          .attr("cy", function(d) { return y(d[p.y]); })
          .attr("r", size/30)
          .style("fill", "#000");  
    } // End plot functiong
    
    function cross(arr) {
      var c = [], n = leaderList.length, i, j;
      for (i = 0; i < n; i++) 
        for (j = 0; j < n; j++) {
          var miLeader = leaderList[i].mi;
          var mjLeader = leaderList[j].mi;

          c.push({x: arr[miLeader], i: i, y: arr[mjLeader], j: j, mi: miLeader, mj: mjLeader});
        }
      return c;
    }


    function disSim(mi, mj){
      if (mi<mj){
         var k = mj*(mj-1)/2+mi; 
         return 1-data2[k]["Monotonic"];
      }
      else if (mi>mj){
        var k = mi*(mi-1)/2+mj; 
        return 1-data2[k]["Monotonic"];
      }
      else{
        return 0; // Monotonic==1 if same variable for x and y
      }
    }  

    // Implementation of leader algorithm
    // arr: input variables
    // sim: similarity funciton
    function leaderAlgorithm(arr, disSim){
      var r = 0.5;
      var leaderList = [];
      for (var i=0; i< arr.length; i++){
        var minDis = 10000;
        var minIndex = -1;
        // Finding the leader
        for (var l=0; l< leaderList.length; l++){
          var dis = disSim(i,leaderList[l].mi);
          if (dis<minDis){
            minDis=dis;
            minIndex = l;
          }
        }  
        // Checking 
        if (minIndex>=0 && minDis<r){   // If found a leader (with minDis)
          var oldLeader = leaderList[minIndex];
          oldLeader.children.push(i);
        }
        else{
          var newLeader = {};
          newLeader.mi = i;
          newLeader.children = []; 
          leaderList.push(newLeader);
        }  
      }
      return leaderList;
    }

    //var cell = svg.selectAll(".cell")
    //  .each(plot2);

    // Plot2 function ****************************
    /*function plot2(p) {
      var cell = d3.select(this);
      cell.selectAll(".frame").attr("fill", function(d){
        if (p.i<p.j){
           var k = p.mj*(p.mj-1)/2+p.mi; 
           return colorRedBlue(data2[k]["Monotonic"]);
        }
        else if (p.i>p.j){
          var k = p.mi*(p.mi-1)/2+p.mj; 
          return colorRedBlue(data2[k]["Monotonic"]);
        }
        else{
          return "#fff";
        }
      })
    }*/
  });  


 




// *************************BRUSHING **********************************
 var brushCell;
  // Clear the previously-active brush, if any.
  function brushstart(p) {
    if (brushCell !== this) {
      d3.select(brushCell).call(brush.clear());
      x.domain(domainByTrait);
      y.domain(domainByTrait);
      brushCell = this;
    }
  }
  // Highlight the selected circles.
  function brushmove(p) {
    var e = brush.extent();
    svg.selectAll("circle").classed("hidden", function(d) {
      return e[0][0] > d[p.x] || d[p.x] > e[1][0]
          || e[0][1] > d[p.y] || d[p.y] > e[1][1];
    });
  }
  // If the brush is empty, select all circles.
  function brushend() {
    if (brush.empty()) svg.selectAll(".hidden").classed("hidden", false);
  }
});
</script>
</body>